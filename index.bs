<pre class="metadata">
Shortname: webxr-hit-test
Title: WebXR Hit Test Module
Group: immersivewebwg
Status: CG-DRAFT
Level: 1
ED: https://immersive-web.github.io/hit-test/
Repository: immersive-web/hit-test
Mailing List Archives: https://lists.w3.org/Archives/Public/public-immersive-web/

!Participate: <a href="https://github.com/immersive-web/hit-test/issues/new">File an issue</a> (<a href="https://github.com/immersive-web/hit-test/issues">open issues</a>)
!Participate: <a href="https://lists.w3.org/Archives/Public/public-immersive-web/">Mailing list archive</a>
!Participate: <a href="irc://irc.w3.org:6665/">W3C's #immersive-web IRC</a>

Editor: Piotr Bialecki 114482, Google http://google.com/, bialpio@google.com

Abstract: Describes a method for performing hit tests against real world geometry to be used with the WebXR Device API.
</pre>

<pre class="anchors">
spec: WebXR Device API - Level 1; urlPrefix: https://www.w3.org/TR/webxr/#
    type: interface; text: XRSession; url: xrsession-interface
    type: interface; text: XRFrame; url: xrframe-interface
    type: dfn; text: native origin; url: xrspace-native-origin
    type: dfn; text: effective origin; url: xrspace-effective-origin
    type: dfn; text: XR device; url: xrsession-xr-device
    type: dfn; text: XR animation frame; url: xr-animation-frame
    type: dfn; text: list of animation frame callbacks; url: list-of-animation-frame-callbacks
    type: callback; text: XRFrameRequestCallback; url: callbackdef-xrframerequestcallback
    type: interface; text: XRRigidTransform; url: xrrigidtransform-interface
    type: attribute; text: matrix; for: XRRigidTransform; url: dom-xrrigidtransform-matrix
    type: dfn; text: matrix; url: matrix
    type: dfn; text: normalize; url: normalize
spec: ECMAScript; urlPrefix: https://tc39.github.io/ecma262/#
    type: method; text: IsDetachedBuffer; url: sec-isdetachedbuffer
</pre>

<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">

<style>
  .non-normative::before {
    content: "This section is non-normative.";
    font-style: italic;
  }
  .tg {
    border-collapse: collapse;
    border-spacing: 0;
  }
  .tg th {
    border-style: solid;
    border-width: 1px;
    background: #90b8de;
    color: #fff;
    font-family: sans-serif;
    font-weight: bold;
    border-color: grey;
  }
  .tg td {
    padding: 4px 5px;
    background-color: rgb(221, 238, 255);
    font-family: monospace;
    border-style: solid;
    border-width: 1px;
    border-color: grey;
    overflow: hidden;
    word-break: normal;
  }
</style>

Introduction {#intro}
============

<section class="non-normative">

This module describes a mechanism for allowing WebXR applications to cast rays into the users' real world environment and report back, to the best of the XR device's knowledge, the point at which the ray intersected with a physical object along with the orientation of the intersected surface. This allows for virtual objects to be placed in alignment with those surfaces, such as placing objects realistically on the floor or attaching them to a wall. The hit test API is an extension to <a href="https://www.w3.org/TR/webxr/">WebXR Device API</a> and builds on top of <a href="https://github.com/immersive-web/webxr-ar-module/">WebXR Augmented Reality Module</a>.

</section>

Terminology {#terminology}
-----------

Hit testing, as understood by this document, is an act of checking if an idealised mathematical ray (half-line) intersects with real world as understood by the underlying Augmented Reality hardware & software. Ray intersections against virtual objects created by the application consuming the API are explicitly out of scope of the hit test API.

Hit test options {#hit-test-options}
================

XRHitTestTrackableType {#hit-test-trackable-type-enum}
----------------------

An {{XRHitTestTrackableType}} enum specifies the type of entity that can be used for the purposes of hit test source creation.

<script type="idl">
enum XRHitTestTrackableType {
  "point",
  "plane"
};
</script>

- A hit test trackable of type <dfn enum-value for="XRHitTestTrackableType">"point"</dfn> indicates that the hit test results will be computed based on the feature points detected by the underlying Augmented Reality system.
- A hit test trackable of type <dfn enum-value for="XRHitTestTrackableType">"plane"</dfn> indicates that the hit test results will be computed based on the planes detected by the underlying Augmented Reality system.

XRHitTestOptionsInit {#hit-test-options-dictionary}
--------------------
Issue: Add effectiveOffsetRay / effectiveEntityTypes?

An {{XRHitTestOptionsInit}} dictionary represents a set of configurable values that affect the behavior of the hit test being performed.

<script type="idl">
dictionary XRHitTestOptionsInit {
  required XRSpace space;
  FrozenArray<XRHitTestTrackableType> entityTypes;
  XRRay offsetRay;
};
</script>

The <dfn dict-member for="XRHitTestOptionsInit">space</dfn> dictionary member specifies {{XRSpace}} relative to which the {{XRHitTestOptionsInit/offsetRay}} is specified.

The <dfn dict-member for="XRHitTestOptionsInit">entityTypes</dfn> dictionary member specifies array of <a enum lt="XRHitTestTrackableType">XRHitTestTrackableTypes</a> that will be used to compute results of the hit test. If not specified by the application, it will be assumed that it's set to an array containing single element, {{XRHitTestTrackableType/"plane"}}.

The <dfn dict-member for="XRHitTestOptionsInit">offsetRay</dfn> dictionary member specifies {{XRRay}} used to perform hit test. The {{XRHitTestOptionsInit/offsetRay}} is expressed in a coordinate system defined by {{XRHitTestOptionsInit/space}}. If not specified by the application, it will be assumed that it's set to an {{XRRay}} constructed by invoking {{XRRay/XRRay()}} without any parameters.

Hit test source {#hit-test-source}
===============

XRHitTestSource {#hit-test-source-interface}
---------------

<script type="idl">
[SecureContext, Exposed=Window]
interface XRHitTestSource {
  void cancel();
};
</script>

The {{XRHitTestSource}} object serves as a handle to an active subscription to hit test.

Each {{XRHitTestSource}} has an associated <dfn for="XRHitTestSource">session</dfn> which stores an {{XRSession}} that was used to create the hit test source.

Each {{XRHitTestSource}} has an associated <dfn for="XRHitTestSource">native origin</dfn> which stores information sufficient to identify the [=/native origin=] of an {{XRSpace}} that was used to [=request hit test=]. This information will be subsequently used when computing hit test results.

Each {{XRHitTestSource}} has an associated <dfn for="XRHitTestSource">entity types</dfn>, which is an array of <a enum lt="XRHitTestTrackableType">XRHitTestTrackableTypes</a> describing which entity types will be considered when computing hit test results.

Each {{XRHitTestSource}} has an associated <dfn for="XRHitTestSource">offset ray</dfn>, which is an {{XRRay}} that will be used when computing hit test results.

{{XRHitTestSource}} is considered <dfn for="XRHitTestSource">active</dfn> for as long as it's present in [=XRHitTestSource/session=]'s [=XRSession/set of active hit test sources=].

<div class="algorithm" data-algorithm="create-hit-test-source">

In order to <dfn>create a hit test source</dfn> from |session|, |space|, |entityTypes| and |offsetRay|, the User Agent MUST run the following steps:
    1. Let |hitTestSource| be a new {{XRHitTestSource}}.
    1. Initialize |hitTestSource|'s [=XRHitTestSource/session=] to |session|.
    1. Initialize |hitTestSource|'s [=XRHitTestSource/native origin=] to |space|'s [=/native origin=].
    1. Initialize |hitTestSource|'s [=XRHitTestSource/entity types=] to |entityTypes|.
    1. Compute |transformedOffsetRay| from |offsetRay| and |space| such that |transformedOffsetRay|, when interpreted in |space|'s [=/native origin=] coordinate system, represents the same ray as |offsetRay| does when interpreted in |space|'s [=effective origin=] coordinate system.
    1. Initialize |hitTestSource|'s [=XRHitTestSource/offset ray=] to |transformedOffsetRay|.
    1. Return |hitTestSource|.

</div>

The <dfn method for="XRHitTestSource">cancel()</dfn> method, when invoked on {{XRHitTestSource}} |hitTestSource|, signals that the application is no longer interested in obtaining hit test results for the specified |hitTestSource|.

<div class="algorithm" data-algorithm="cancel-hit-test-source">

When {{XRHitTestSource/cancel()}} method is invoked, the User Agent MUST <dfn>cancel a hit test source</dfn> by running the following steps:
    1. If the |hitTestSource| is not [=active=], throw an {{InvalidStateError}} and abort these steps.
    1. Remove |hitTestSource| from [=XRHitTestSource/session=]'s [=XRSession/set of active hit test sources=].

</div>

When the application no longer retains any references to a particular {{XRHitTestSource}} <var ignore=''>hitTestSource</var>, User Agent CAN [=cancel a hit test source=] that is still [=active=]. The cancelation CAN happen at an unspecified time (or not at all) and the application SHOULD NOT rely on this behavior for cleanup.

Hit test result {#hit-test-result}
===============

XRHitTestResult {#xr-hit-test-result-interface}
---------------

<script type="idl">
[SecureContext, Exposed=Window]
interface XRHitTestResult {
  XRPose? getPose(XRSpace baseSpace);
};
</script>

A {{XRHitTestResult}} contains single result of a hit test.

Each {{XRHitTestResult}} has an associated <dfn for="XRHitTestResult">frame</dfn> which is an {{XRFrame}} for which the result was computed.

Each {{XRHitTestResult}} has an associated <dfn for="XRHitTestResult">native origin</dfn>.

Issue: add a section for system-specific types (native result, native entity type, planes, points, describe requirements for native hit test)

<div class="algorithm" data-algorithm="create-hit-test-result">

In order to <dfn>create a hit test result</dfn> given {{XRFrame}} |frame|, array of {{XRHitTestTrackableType}} |entityTypes|, and |nativeResult|, the User Agent MUST run the following steps:
    1. Let |hitTestResult| be a new {{XRHitTestResult}}.
    1. Query [=/XR device=] for the entity type, |nativeEntityType| of the |nativeResult|.
    1. Convert |nativeEntityType| to |entityType| of type {{XRHitTestTrackableType}}.
    1. If |entityType| is <code>null</code> or is not present in |entityTypes| array, return <code>null</code> and abort these steps.
    1. Set |hitTestResult|'s [=XRHitTestResult/frame=] to |frame|.
    1. Set |hitTestResult|'s [=XRHitTestResult/native origin=] to a native origin obtained from |nativeResult|.
    1. Return |hitTestResult|.

</div>

The <dfn method for="XRHitTestResult">getPose(|baseSpace|)</dfn> method, when invoked on {{XRHitTestResult}} |hitTestResult|, provides the pose of the |hitTestResult| relative to |baseSpace| as an {{XRPose}}, at the time represented by [=XRHitTestResult/frame=].

<div class="algorithm" data-algorithm="populate-result-pose">

When {{XRHitTestResult/getPose(baseSpace)}} method is invoked, the User Agent MUST run the following steps:
1. WIP

</div>

Issue: fill the algorithm out based on XRFrame.getPose().

Requesting hit test {#requesting-hit-test}
===================

<script type="idl">
partial interface XRSession {
  Promise<XRHitTestSource> requestHitTestSource(XRHitTestOptionsInit options);
};

partial interface XRFrame {
  FrozenArray<XRHitTestResult> getHitTestResults(XRHitTestSource hitTestSource);
};
</script>

The {{XRSession}} is extended to contain an associated <dfn for="XRSession">set of active hit test sources</dfn> that will be used when computing hit test results.

The {{XRFrame}} is extended to contain an associated <dfn for="XRFrame">map of hit test sources to hit test results</dfn> that stores a mapping from {{XRHitTestSource}} to an array of <a interface lt="XRHitTestResult">XRHitTestResults</a>.

The application can <dfn>request hit test</dfn> using {{XRSession}}'s {{XRSession/requestHitTestSource()}} method.

<div class="algorithm" data-algorithm="request-hit-test-source">

The <dfn method for="XRSession">requestHitTestSource(|options|)</dfn> method, when invoked on an {{XRSession}} |session|, MUST run the following steps:

  1. Let |promise| be [=a new Promise=].
  1. Validate that |options| dictionary contains {{XRHitTestOptionsInit/space}} key with a value of type {{XRSpace}} - if not, [=/reject=] |promise| with a {{TypeError}} and abort these steps.
  1. Initialize |space| of type {{XRSpace}} to the value contained in |options| dictionary under the {{XRHitTestOptionsInit/space}} key.
  1. Initialize |entityTypes| as follows:
    <dl class="switch">
      <dt>If |options| dictionary contains {{XRHitTestOptionsInit/entityTypes}} key</dt>
      <dd>Initialize |entityTypes| to the value contained in |options| dictionary under {{XRHitTestOptionsInit/entityTypes}} key.</dd>
      <dt>Else</dt>
      <dd>Initialize |entityTypes| to a one-element array of <a enum lt="XRHitTestTrackableType">XRHitTestTrackableTypes</a> containing {{XRHitTestTrackableType/"plane"}}.</dd>
    </dl>
  1. Initialize |offsetRay| of type {{XRRay}} as follows:
    <dl class="switch">
      <dt>If |options| dictionary contains {{XRHitTestOptionsInit/offsetRay}} key</dt>
      <dd>Set |offsetRay| to the value of {{XRHitTestOptionsInit/offsetRay}}.</dd>
      <dt>Else</dt>
      <dd>Set |offsetRay| to the ray constructed using a call to {{XRRay()}} with default parameters.</dd>
    </dl>
  1. [=Create a hit test source=], |hitTestSource|, with |session|, |space|, |entityTypes| and |offsetRay|.
  1. If |hitTestSource| is <code>null</code>, [=/reject=] |promise| with an {{OperationError}} and abort these steps.
  1. Store created |hitTestSource| in |session|'s [=set of active hit test sources=].
  1. [=/Resolve=] |promise| with created |hitTestSource|.

</div>

Issue: does the specification have to be explicit about silently dropping unrecognized entries from {{XRHitTestOptionsInit/entityTypes}} array?

Computing hit test results {#computing-hit-test-results}
==========================

Every time User Agent processes [=/XR animation frame=] for {{XRSession}}, it needs to <dfn>compute hit test results</dfn>. This MUST happen prior to invoking any of the callbacks from [=/list of animation frame callbacks=] of a given {{XRSession}}.

<div class="algorithm" data-algorithm="compute-hit-test-results">

In order to compute hit test results for a given {{XRFrame}} |frame|, for each hit test source, |hitTestSource|, that is present in {{XRFrame/session}}'s [=XRSession/set of active hit test sources=], the User Agent MUST perform the following steps:
    1. Let the |entityTypes| be the |hitTestSource|'s [=XRHitTestSource/entity types=].
    1. Query the [=/XR device=]'s tracking system for |hitTestSource|'s [=XRHitTestSource/native origin=]'s latest |coordinates|.
    1. Treat |hitTestSource|'s [=XRHitTestSource/offset ray=], |offsetRay|, as if expressed relative to |coordinates| and query [=/XR device=] for hit test results, |nativeResults|, of the |hitTestSource|'s [=XRHitTestSource/offset ray=] with the environment as understood by the [=/XR device=].
    1. Let |hitTestResults| be an empty [=/list=].
    1. Given the |frame| and |entityTypes|, for each native hit test result |nativeResult| in |nativeResults|, perform the following steps:
        1. [=Create a hit test result=], |hitTestResult|.
        1. If |hitTestResult| is <code>null</code>, continue to the next entry in |nativeResults|.
        1. Add |hitTestResult| to |hitTestResults| such that the list remains sorted by the [=distance along the ray=] from |offsetRay| to |nativeResult|.
    1. Store |hitTestResults| in |frame|'s [=XRFrame/map of hit test sources to hit test results=] under the |hitTestSource| key.

</div>

Obtaining hit test results {#obtaining-hit-test-results}
==========================

The application can <dfn>obtain hit test results</dfn> from an {{XRHitTestSource}} by using {{XRFrame}}'s {{XRFrame/getHitTestResults()}} method.

<div class="algorithm" data-algorithm="obtain-hit-test-results">

The <dfn method for="XRFrame">getHitTestResults(|hitTestSource|)</dfn> method, when invoked on an {{XRFrame}} |frame|, MUST run the following steps:
    1. Look up an entry for |hitTestSource| in |frame|'s [=XRFrame/map of hit test sources to hit test results=] and assign it to |results|.
    1. Return |results|.

</div>

Issue: Improve - this probably needs to ensure that frame is active, etc.

Geometric primitives {#geometric-primitives}
====================

XRRay {#xrray-interface}
-----

An {{XRRay}} is a geometric ray described by an {{XRRay/origin}} point and {{XRRay/direction}} vector.

An {{XRRay}} contains a <dfn for=XRRay>matrix</dfn> which is a [=/matrix=].

<script type="idl">
[SecureContext, Exposed=Window,
 Constructor(optional DOMPointInit origin = {}, optional DOMPointInit direction = {}),
 Constructor(XRRigidTransform transform)]
interface XRRay {
  [SameObject] readonly attribute DOMPointReadOnly origin;
  [SameObject] readonly attribute DOMPointReadOnly direction;
  [SameObject] readonly attribute Float32Array matrix;
};
</script>

<div class="algorithm" data-algorithm="construct-ray-origin-direction">

The <dfn constructor for="XRRay">XRRay(|origin|, |direction|)</dfn> constructor MUST perform the following steps when invoked:

  1. Let |ray| be a new {{XRRay}}.
  1. Initialize |ray|'s {{XRRay/origin}}’s {{DOMPointReadOnly/x}} value to |origin|'s x dictionary member, {{DOMPointReadOnly/y}} value to |origin|'s y dictionary member, {{DOMPointReadOnly/z}} value to |origin|'s z dictionary member and {{DOMPointReadOnly/w}} to <code>1.0</code>.
  1. Initialize |ray|'s {{XRRay/direction}}’s {{DOMPointReadOnly/x}} value to |direction|'s x dictionary member, {{DOMPointReadOnly/y}} value to |direction|'s y dictionary member, {{DOMPointReadOnly/z}} value to |direction|'s z dictionary member and {{DOMPointReadOnly/w}} value to to <code>0.0</code>.
  1. [=Normalize=] the {{DOMPointReadOnly/x}}, {{DOMPointReadOnly/y}}, and {{DOMPointReadOnly/z}} components of |ray|'s {{XRRay/direction}}.
  1. Initialize |ray|'s [=XRRay/matrix=] to <code>null</code>.
  1. Return |ray|.

</div>

Issue: default value for direction's z component is not correct above (if the caller does not specify direction, we won't be able to normalize it since it defaults to all 0's).

<div class="algorithm" data-algorithm="construct-ray-transform">

The <dfn constructor for="XRRay">XRRay(|transform|)</dfn> constructor MUST perform the following steps when invoked:

  1. Let |ray| be a new {{XRRay}}.
  1. Initialize |ray|'s {{XRRay/origin}} to <code>{ x: 0.0, y: 0.0, z: 0.0, w: 1.0 }</code>.
  1. Initialize |ray|'s {{XRRay/direction}} to <code>{ x: 0.0, y: 0.0, z: -1.0, w: 0.0 }</code>.
  1. Transform |ray|'s {{XRRay/origin}} by premultiplying the |transform|'s {{XRRigidTransform/matrix}} and set |ray| to the result.
  1. Transform |ray|'s {{XRRay/direction}} by premultiplying the |transform|'s {{XRRigidTransform/matrix}} and set |ray| to the result.
  1. [=Normalize=] the {{DOMPointReadOnly/x}}, {{DOMPointReadOnly/y}}, and {{DOMPointReadOnly/z}} components of |ray|'s {{XRRay/direction}}
  1. Return |ray|.

</div>

The <dfn attribute for="XRRay">origin</dfn> attribute defines the 3-dimensional point in space that the ray originates from, given in meters. The {{XRRay/origin}}'s {{DOMPointReadOnly/w}} attribute MUST be <code>1.0</code>.

The <dfn attribute for="XRRay">direction</dfn> attribute defines the ray's 3-dimensional directional vector. The {{XRRay/direction}}'s {{DOMPointReadOnly/w}} attribute MUST be <code>0.0</code> and the vector MUST be normalized to have a length of <code>1.0</code>.

The <dfn attribute for="XRRay">matrix</dfn> attribute is a [=/matrix=] which represents a transform that can be used to position objects along the {{XRRay}}. It is a transform from a ray originating at <code>[0, 0, 0]</code> and extending down the negative Z axis to the ray described by the {{XRRay}}'s {{XRRay/origin}} and {{XRRay/direction}}. Such a matrix MUST be one that has a rotation component which leaves any vector perpendicular to {{XRRay/direction}} and the <code>Z</code> axis unchanged. This attribute MUST be computed by [=XRRay/obtain the matrix|obtaining the matrix=] for the {{XRRay}}. This attribute SHOULD be lazily evaluated.

Note: The {{XRRay}}'s {{XRRay/matrix}} can be used to easily position graphical representations of the ray when rendering.

<div class="algorithm" data-algorithm="obtain-ray-matrix">

To <dfn for="XRRay">obtain the matrix</dfn> for a given {{XRRay}} |ray|

  1. If |ray|'s [=XRRay/matrix=] is not <code>null</code>, perform the following steps:
    1. If the operation {{IsDetachedBuffer}} on [=XRRay/matrix=] is <code>false</code>, return |ray|'s [=XRRay/matrix=].
  1. Let |z| be the vector <code>[0, 0, -1]</code>
  1. Let |axis| be the vector cross product of |z| and |ray|'s {{XRRay/direction}}, <code>z × direction</code>
  1. Let |cos_angle| be the scalar dot product of |z| and |ray|'s {{XRRay/direction}}, <code>z · direction</code>
  1. Set |rotation| based on the following:
    <dl class="switch">
      <dt> If |cos_angle| is greater than -1 and less than 1
      <dd> Set |rotation| to the rotation matrix representing a right handed planar rotation around |axis| by <code>arccos(cos_angle)</code>.
      <dt> Else, if |cos_angle| is -1
      <dd> Set |rotation| to the rotation matrix representing a right handed planar rotation around vector <code>[1, 0, 0]</code> by <code>arccos(cos_angle)</code>.
      <dt> Else
      <dd> Set |rotation| to an identity matrix.
    </dl>
  1. Let |translation| be the translation matrix with components corresponding to |ray|'s {{XRRay/origin}}
  1. Let |matrix| be the result of premultiplying |rotation| from the left onto |translation| (i.e. <code>translation * rotation</code>) in column-vector notation.
  1. Set |ray|'s [=XRRay/matrix=] to |matrix|
  1. Return |matrix|

</div>

<div class="algorithm" data-algorithm="distance-along-ray">

The <dfn>distance along the ray</dfn>, |distance|, from {{XRRay}} |ray| to any entity |entity| is defined such that <code>|ray|.origin + |ray|.direction * |distance|</code> results in a point beloning to the entity |entity|,|distance| is non-negative, and there does not exist a smaller value of |distance| for the above predicate to still hold. It is up to the [=/XR device=] to define the meaning of "point belonging to an entity".

</div>

Issue: The above definition ignores the existence of open sets - do we need to care about them?

Native device concepts {#native-device-concepts} 
======================

<section class="non-normative">

User Agents implementing hit test API must have a way of obtaining information about user's environment from underlying XR device. This section attempts to describe requirements and concepts related to native capabilities of the device and is by neccesity sufficiently under-specified to leave ample room for different underlying frameworks / devices.

</section>

Native hit test {#native-hit-test}
---------------

In this specification it is assumed that [=/XR device=] exposes a way for the User Agent to query for hit test results that satisfies the following requirements:
- Accepts a 3D ray that will be tested against user's environment.
- Returns a collection of 3D poses representing intersection points of the passed in ray with user's environment. Each entry in the collection should also contain information about the type of the native entity that was used to obtain that native result.

Note: For devices that do not expose the hit test functionality natively, it might still be possible for User Agents to implement this specification by leveraging other ways of obtaining the information about user's environment that might be exposed by the XR device.

Native entity type {#native-entity-type}
------------------

Native hit test results returned by [=XR device=] should contain information about the type of the entity used to compute the result. Such native types might consist of, but not be limited to:
- Point - signifies that hit test result was computed based on characteristic points found in user's environment.
- Plane - signifies that hit test result was computed based on planes detected in user's environment.

Issue: add algorithm to convert from native to XRHitTestTrackableType.
Issue: native hit test can return results that fall outside of plane's polygon - how should those be handled?

<div class="algorithm" data-algorithm="convert-native-type-to-trackable-type">

</div>

Native hit test result {#native-hit-test-result}
----------------------




Acknowledgements {#ack}
================

The following individuals have contributed to the design of the WebXR Hit Test specification:
